---
cip: 227
title: Composable Vehicle NFTs Standard for Core Blockchain
description: 
keywords: []
author: Ockert Loubser
lang: en-US
status: [draft]
tags: []
date: 2022-12-01
discussions-to: 
---
<!--Introduction-->

<!--truncate-->

## Abstract
This CIP defines a standard for composable Non-Fungible Tokens (NFTs) representing vehicles and their parts on the Core Blockchain (XCB). It extends CIP-721 for basic NFT functionality, incorporates CIP-150 for on-chain key-value metadata storage, and CIP-151 for token lifecycle management. The standard introduces composability through a Composer contract that allows attaching/detaching part NFTs to a vehicle holder NFT, enabling modular ownership, upgrades, and audit trails with decentralized storage references (IPNS) and zero-trust fingerprinting (SHA256).


## Motivation
Tokenizing physical assets like vehicles requires more than basic NFTs: parts must be interchangeable, lifecycles (e.g., expiration for warranties) enforced, and compositions auditable. Existing standards like CIP-721 provide ownership tracking but lack native support for hierarchy, modularity, and integrated metadata for real-world assets (RWAs). This CIP addresses these gaps by standardizing interfaces for part NFTs, vehicle holder NFTs, and a composer mechanism, facilitating integrations with ERP systems, supply chains, and dApps like CorePass ID. It enables use cases such as customizable vehicle configurations, provenance tracking, and loyalty programs for manufacturers.


## Specification
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119.
This standard defines three main interfaces: IPartNFT for individual components, IVehicleNFT for the holder token, and IComposer for managing compositions. Contracts implementing these MUST also conform to CIP-721 for interoperability.
Interfaces
IPartNFT Interface
This interface extends CIP-721 with additional metadata for parts, including lifecycle (CIP-151) and decentralized storage.
text
CollapseWrap
Copy
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.20;



import "@core-blockchain/contracts/interfaces/ICBC721.sol"; // CIP-721 equivalent



interface IPartNFT is ICBC721 {

   struct PartMetadata {

       string specs; // JSON with details

       string ipnsNamespace; // Decentralized storage (IPNS for brand/model)

       bytes32 fingerprint; // SHA256 for zero-trust audit trail

       uint256 expiration; // CIP-151 lifecycle (0 = none)

       bool locked; // Prevent edits for provenance

       uint256 createdAt; // Timestamp of creation

   }



   function partMetadata(uint256 tokenId) external view returns (PartMetadata memory);



   function mintPart(

       address to,

       uint256 tokenId,

       string calldata specs,

       string calldata ipnsNamespace,

       bytes32 fingerprint,

       uint256 expiration

   ) external;



   function attachToVehicle(uint256 tokenId, address composerAddress) external;



   function setExpiration(uint256 tokenId, uint256 newExpiration) external;



   function lockPart(uint256 tokenId) external;



   function getPartMetadata(uint256 tokenId) external view returns (

       string memory specs,

       string memory ipnsNamespace,

       bytes32 fingerprint,

       uint256 expiration,

       bool locked,

       uint256 createdAt

   );



   function isPartExpired(uint256 tokenId) external view returns (bool);



   function isPartLocked(uint256 tokenId) external view returns (bool);



   event PartMinted(uint256 indexed tokenId, address indexed to, bytes32 fingerprint);

   event PartExpirationUpdated(uint256 indexed tokenId, uint256 newExpiration);

   event PartLocked(uint256 indexed tokenId);

}
mintPart: MUST mint a new part NFT with the provided metadata. The fingerprint ensures zero-trust auditability.
attachToVehicle: MUST transfer the part to the composer for attachment, checking locks and expiration.
setExpiration: MUST update the expiration timestamp per CIP-151, only if not locked.
lockPart: MUST seal the part's metadata to prevent further changes.
View Functions: MUST provide read access to metadata, expiration status, and lock status.
tokenURI: SHOULD return an IPNS-based URI for decentralized metadata access.
IVehicleNFT Interface
This interface extends CIP-721 with CIP-150 KV metadata storage, sealing, and batch updates.
text
CollapseWrap
Copy
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.20;



import "@core-blockchain/contracts/interfaces/ICBC721.sol"; // CIP-721 equivalent



interface IVehicleNFT is ICBC721 {

   function mintVehicle(address to, uint256 tokenId, string calldata overallSpecs, string calldata vin) external;



   function setValue(uint256 tokenId, string calldata key, string calldata value) external;



   function batchSetValues(uint256 tokenId, string[] calldata keys, string[] calldata values) external;



   function seal(uint256 tokenId) external;



   function getAttachedParts(uint256 tokenId) external view returns (string memory);



   function kvMetadata(uint256 tokenId, string calldata key) external view returns (string memory);



   function sealed(uint256 tokenId) external view returns (bool);



   function createdAt(uint256 tokenId) external view returns (uint256);



   event VehicleMinted(uint256 indexed tokenId, address indexed to, string vin);

   event MetadataUpdated(uint256 indexed tokenId, string key, string value);

   event BatchMetadataUpdated(uint256 indexed tokenId, string[] keys, string[] values);

   event VehicleSealed(uint256 indexed tokenId);

}
mintVehicle: MUST mint the vehicle NFT with initial specs and VIN in KV metadata.
setValue / batchSetValues: MUST update KV metadata per CIP-150, with batching inspired by CIP-3005 for efficiency. Disallowed if sealed.
seal: MUST make the metadata immutable.
getAttachedParts: MUST return a JSON string of attached parts from KV.
View Functions: MUST expose KV values, seal status, and creation timestamp.
IComposer Interface
This interface defines the composability logic for attaching/detaching parts.
text
CollapseWrap
Copy
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.20;



import "@core-blockchain/contracts/interfaces/ICBC721Receiver.sol";



interface IComposer is ICBC721Receiver {

   function attachPart(uint256 vehicleTokenId, address partContract, uint256 partTokenId) external;



   function batchAttachParts(uint256 vehicleTokenId, address[] calldata partContracts, uint256[] calldata partTokenIds) external;



   function detachPart(uint256 vehicleTokenId, uint256 index) external;



   function transferVehicleWithParts(uint256 vehicleTokenId, address newOwner, bool bundleParts) external;



   function getAttachedParts(uint256 vehicleTokenId) external view returns (address[] memory contracts, uint256[] memory tokenIds);



   function getAttachedPartsCount(uint256 vehicleTokenId) external view returns (uint256);



   event PartAttached(uint256 indexed vehicleTokenId, address partContract, uint256 partTokenId);

   event PartDetached(uint256 indexed vehicleTokenId, address partContract, uint256 partTokenId);

}
attachPart / batchAttachParts: MUST transfer parts to escrow, record attachments, update vehicle metadata, and check expiration/locks.
detachPart: MUST remove the part from composition and transfer back to owner.
transferVehicleWithParts: MUST handle bundled or unbundled transfers of the vehicle and parts.
View Functions: MUST provide lists and counts of attached parts.
Metadata JSON Schema
For part and vehicle metadata (via tokenURI or KV):
text
CollapseWrap
Copy
{

 "title": "Composable Vehicle NFT Metadata",

 "type": "object",

 "properties": {

   "specs": { "type": "string", "description": "JSON details of the part/vehicle" },

   "ipnsNamespace": { "type": "string", "description": "IPNS path for decentralized data" },

   "fingerprint": { "type": "string", "description": "SHA256 hash for audit trail" },

   "expiration": { "type": "integer", "description": "Unix timestamp for expiration" },

   "attached_parts": { "type": "array", "description": "Array of {contract: address, id: uint256}" }

 }

}
Timestamp Format
Use Unix epoch seconds. For expiration, 0 indicates no expiration.



## Rationale
This design groups parts into hierarchies (10-20 major assemblies) to reduce on-chain complexity while enabling modularity. Composability via escrow in the Composer prevents unauthorized sales of attached parts. Integration with CIP-150/151 ensures durable, lifecycle-aware metadata. Batch operations optimize energy costs on XCB.


## Backwards Compatibility
Fully compatible with CIP-721 (all tokens are transferable NFTs), CIP-150 (KV usage), and CIP-151 (expiration logic). Existing CIP-721 contracts can be extended without breaking interoperability with wallets or marketplaces.


## Test Cases
Implementations SHOULD include unit tests for:
Minting and metadata validation.
Attachment/detachment with expiration checks.
Sealing and immutability.
Batch operations and energy estimates.
Example test suite (in Ylem/Foxar):
Test mintPart reverts on invalid inputs.
Test attachPart succeeds only if not expired/locked.
Test transferVehicleWithParts bundles parts correctly.



## Implementation



## Security Considerations
Use safeTransferFrom to prevent reentrancy.
Seal metadata post-assembly to avoid tampering.
Validate contract existence (code.length > 0) to prevent invalid addresses.
Off-chain systems (e.g., ERP) SHOULD verify fingerprints for zero-trust.
Potential risks: High part counts could increase energy; mitigate with hierarchy and batches.



## Copyright

Copyright and related rights waived via [CC0](https://creativecommons.org/publicdomain/zero/1.0/).
